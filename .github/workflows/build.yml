name: Build and Publish gnb

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag:
        description: Release tag to build (e.g. v1.6.0.a)
        required: true
        default: v1.6.0.a

env:
  PROJECT: gnb
  LATEST: v1.6.0.a

jobs:
  build:
    name: build-${{ matrix.os }}-${{ matrix.arch }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          # linux
          - { os: linux,   platform: linux,   arch: amd64,        ext: tgz,  makefile: Makefile.linux }
          - { os: linux,   platform: linux,   arch: arm64,        ext: tgz,  makefile: Makefile.linux }
          - { os: linux,   platform: linux,   arch: armv7-softfp, ext: tgz,  makefile: Makefile.linux }
          - { os: linux,   platform: linux,   arch: armv7-hardfp, ext: tgz,  makefile: Makefile.linux }
          - { os: linux,   platform: linux,   arch: mips,         ext: tgz,  makefile: Makefile.linux }
          - { os: linux,   platform: linux,   arch: mipsel,       ext: tgz,  makefile: Makefile.linux }
          - { os: linux,   platform: linux,   arch: mips64,       ext: tgz,  makefile: Makefile.linux }
          - { os: linux,   platform: linux,   arch: mips64el,     ext: tgz,  makefile: Makefile.linux }
          - { os: linux,   platform: linux,   arch: riscv64,      ext: tgz,  makefile: Makefile.linux }
          # openwrt
          - { os: openwrt, platform: linux,   arch: amd64,        ext: tgz,  makefile: Makefile.openwrt }
          - { os: openwrt, platform: linux,   arch: arm64,        ext: tgz,  makefile: Makefile.openwrt }
          - { os: openwrt, platform: linux,   arch: armv7-softfp, ext: tgz,  makefile: Makefile.openwrt }
          - { os: openwrt, platform: linux,   arch: armv7-hardfp, ext: tgz,  makefile: Makefile.openwrt }
          - { os: openwrt, platform: linux,   arch: mips,         ext: tgz,  makefile: Makefile.openwrt }
          - { os: openwrt, platform: linux,   arch: mipsel,       ext: tgz,  makefile: Makefile.openwrt }
          - { os: openwrt, platform: linux,   arch: mips64,       ext: tgz,  makefile: Makefile.openwrt }
          - { os: openwrt, platform: linux,   arch: mips64el,     ext: tgz,  makefile: Makefile.openwrt }
          - { os: openwrt, platform: linux,   arch: riscv64,      ext: tgz,  makefile: Makefile.openwrt }
          # windows
          - { os: windows, platform: windows, arch: amd64,        ext: zip,  makefile: Makefile.windows }
          - { os: windows, platform: windows, arch: arm64,        ext: zip,  makefile: Makefile.windows }
          - { os: windows, platform: windows, arch: '386',        ext: zip,  makefile: Makefile.windows }
          # darwin
          - { os: darwin,  platform: darwin,  arch: amd64,        ext: tgz,  makefile: Makefile.darwin }
          - { os: darwin,  platform: darwin,  arch: arm64,        ext: tgz,  makefile: Makefile.darwin }
          # freebsd
          - { os: freebsd, platform: freebsd, arch: amd64,        ext: tgz,  makefile: Makefile.freebsd }
          - { os: freebsd, platform: freebsd, arch: arm64,        ext: tgz,  makefile: Makefile.freebsd }

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve TAG
        id: tag
        run: |
          TAG_INPUT='${{ github.event.inputs.tag }}'
          if [ -n "$TAG_INPUT" ]; then
            TAG="$TAG_INPUT"
          else
            # strip refs/tags/
            TAG="${GITHUB_REF##*/}"
          fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "TAG=$TAG" >> "$GITHUB_ENV"

      - name: Select Makefile and build dirs
        id: paths
        run: |
          MAKEFILE="${{ matrix.makefile }}"
          OUT_DIR="$GITHUB_WORKSPACE/.out/${{ steps.tag.outputs.tag }}/${{ matrix.os }}/${{ matrix.arch }}"
          PKG_DIR="$GITHUB_WORKSPACE/.pkg/${{ steps.tag.outputs.tag }}"
          mkdir -p "$OUT_DIR" "$PKG_DIR"
          echo "makefile=$MAKEFILE" >> "$GITHUB_OUTPUT"
          echo "OUT_DIR=$OUT_DIR" >> "$GITHUB_ENV"
          echo "PKG_DIR=$PKG_DIR" >> "$GITHUB_ENV"

      - name: Set source dir to local src
        id: src
        run: |
          SRC_DIR="$GITHUB_WORKSPACE/src"
          echo "src_dir=$SRC_DIR" >> "$GITHUB_OUTPUT"
          echo "SRC_DIR=$SRC_DIR" >> "$GITHUB_ENV"

      - name: Show toolchain info
        run: |
          echo "Building for OS=${{ matrix.os }} Platform=${{ matrix.platform }} Arch=${{ matrix.arch }} Tag=${{ steps.tag.outputs.tag }}"
          make --version || true
          uname -a || true

      - name: Build (${{ matrix.os }}-${{ matrix.arch }})
        env:
          TARGET_OS: ${{ matrix.os }}
          TARGET_PLATFORM: ${{ matrix.platform }}
          TARGET_ARCH: ${{ matrix.arch }}
          VERSION: ${{ steps.tag.outputs.tag }}
          OUT_DIR: ${{ env.OUT_DIR }}
          SRC_DIR: ${{ steps.src.outputs.src_dir }}
        run: |
          if [ ! -f "${{ steps.paths.outputs.makefile }}" ]; then
            echo "Makefile '${{ steps.paths.outputs.makefile }}' not found. Please add it or adjust workflow mapping." >&2
            exit 1
          fi
          echo "Using ${{ steps.paths.outputs.makefile }}"
          # Assumptions:
          # - Per-OS Makefiles accept variables: OS, ARCH, VERSION, OUT_DIR, SRC_DIR
          # - They produce binaries/files into OUT_DIR
          make -f "${{ steps.paths.outputs.makefile }}" \
            OS="$TARGET_OS" ARCH="$TARGET_ARCH" VERSION="$VERSION" OUT_DIR="$OUT_DIR" SRC_DIR="$SRC_DIR" VERBOSE=1

      - name: Package artifact
        run: |
          set -euo pipefail
          ART_NAME="${PROJECT}_${{ matrix.os }}_${{ matrix.arch }}.${{ matrix.ext }}"
          if [ ! -d "$OUT_DIR" ] || [ -z "$(ls -A "$OUT_DIR" 2>/dev/null || true)" ]; then
            echo "No build outputs in $OUT_DIR" >&2
            ls -la "$OUT_DIR" || true
            exit 2
          fi
          echo "Packaging $OUT_DIR -> $PKG_DIR/$ART_NAME"
          if [ "${{ matrix.ext }}" = "zip" ]; then
            (cd "$OUT_DIR" && zip -r9 "$PKG_DIR/$ART_NAME" .)
          else
            tar -C "$OUT_DIR" -czf "$PKG_DIR/$ART_NAME" .
          fi
          echo "ARTIFACT_PATH=$PKG_DIR/$ART_NAME" >> "$GITHUB_ENV"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: artifact-${{ matrix.os }}-${{ matrix.arch }}
          path: ${{ env.ARTIFACT_PATH }}
          if-no-files-found: error

  publish:
    name: publish-all
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Prepare folders
        run: |
          mkdir -p .release

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: .release

      - name: Flatten artifacts
        run: |
          shopt -s nullglob
          mkdir -p .release/flat
          for d in .release/*; do
            [ -d "$d" ] || continue
            for f in "$d"/*; do
              mv "$f" .release/flat/
            done
          done
          ls -la .release/flat

      - name: Resolve TAG
        id: tag
        run: |
          TAG_INPUT='${{ github.event.inputs.tag }}'
          if [ -n "$TAG_INPUT" ]; then
            TAG="$TAG_INPUT"
          else
            TAG="${GITHUB_REF##*/}"
          fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Generate checksums.txt
        run: |
          cd .release/flat
          sha256sum * > checksums.txt
          ls -la

      - name: Upload checksums as artifact
        uses: actions/upload-artifact@v4
        with:
          name: checksums
          path: .release/flat/checksums.txt

      - name: Publish via rsync (optional)
        env:
          DOWNLOAD_SSH_HOST: ${{ secrets.DOWNLOAD_SSH_HOST }}
          DOWNLOAD_SSH_USER: ${{ secrets.DOWNLOAD_SSH_USER }}
          DOWNLOAD_SSH_KEY: ${{ secrets.DOWNLOAD_SSH_KEY }}
          DOWNLOAD_SSH_REMOTE_DIR: ${{ secrets.DOWNLOAD_SSH_REMOTE_DIR }}
          TAG: ${{ steps.tag.outputs.tag }}
        run: |
          set -euo pipefail
          if [ -z "${DOWNLOAD_SSH_HOST:-}" ] || [ -z "${DOWNLOAD_SSH_USER:-}" ] || [ -z "${DOWNLOAD_SSH_KEY:-}" ] || [ -z "${DOWNLOAD_SSH_REMOTE_DIR:-}" ]; then
            echo "SSH upload is skipped because DOWNLOAD_SSH_* secrets are not fully set."
            exit 0
          fi
          echo "Preparing SSH key"
          install -m 700 -d ~/.ssh
          echo "$DOWNLOAD_SSH_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "$DOWNLOAD_SSH_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true
          REMOTE_DIR="$DOWNLOAD_SSH_REMOTE_DIR/$TAG"
          echo "Creating remote dir: $REMOTE_DIR"
          ssh -i ~/.ssh/id_rsa "$DOWNLOAD_SSH_USER@$DOWNLOAD_SSH_HOST" "mkdir -p '$REMOTE_DIR'"
          echo "Uploading artifacts to $REMOTE_DIR"
          rsync -avz --progress -e "ssh -i ~/.ssh/id_rsa" .release/flat/ "$DOWNLOAD_SSH_USER@$DOWNLOAD_SSH_HOST:$REMOTE_DIR/"